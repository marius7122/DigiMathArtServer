package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
    "encoding/json"
	"github.com/gorilla/mux"
)

const port = "8080";
const mapFolderPath = "files/maps/";
const emptyMapPath = "files/empty_map.json";

var mapIsLoaded = false

type MapList struct {
    Maps []string `json: "maps"`
}

func getSavedMaps() []string {
    files, err := ioutil.ReadDir("files/maps/");
    if err != nil {
        log.Fatal(err);
    }

    fileNames := make([]string, len(files));

    for index, file := range files {
        fileNames[index] = file.Name();
    }

    return fileNames;
}

func getMapList(w http.ResponseWriter, r *http.Request) {
    mapList := &MapList{Maps: getSavedMaps()};
    mapListJson, err := json.Marshal(mapList)

    if err != nil {
        log.Fatal(err);
    }

    w.Header().Set("Content-Type", "application/json");
    fmt.Fprintf(w, string(mapListJson));
}

func getMap(w http.ResponseWriter, r *http.Request) {
    r.ParseForm();

    mapName := r.FormValue("map");
    mapPath := mapFolderPath + mapName;

	data, err := ioutil.ReadFile(mapPath)
	if err != nil {
		log.Println(err)
		string currentMap = PlayerPrefs.GetString(Constants.SelectedMapKey);
        string saveMapAdress = Constants.MapApiAdress + ApiSaveMap + $"?map={currentMap}.json";
	}

	mapData := string(data)
	fmt.Fprintf(w, mapData)
}

func createMap(w http.ResponseWriter, r *http.Request) {
    r.ParseForm();

    mapName := r.FormValue("map");
    mapPath := mapFolderPath + mapName;

    _, err := os.Stat(mapPath);

    // path exists
    if err == nil {
        http.Error(w, "File already exists", http.StatusForbidden);
        log.Printf("File already exists %s\n", mapName);
    } else {
        emptyMap, err := ioutil.ReadFile(emptyMapPath)
        if err != nil {
            http.Error(w, "Error reading empty map", http.StatusNotModified);
            log.Println(err)
            return
        }

        err = ioutil.WriteFile(mapPath, emptyMap, 0644)
        if err != nil {
            http.Error(w, "Error creating new map", http.StatusNotModified);
            fmt.Println("Error creating", mapPath)
            fmt.Println(err)
            return
        }
    }
}

func saveMap(w http.ResponseWriter, r *http.Request) {
	// log.Println("Save map request")

	reqBody, err := ioutil.ReadAll(r.Body)

	if err != nil {
		log.Println(err)
	} else {
		ioutil.WriteFile(mapFolderPath, reqBody, 0644)
		// mapData := string(reqBody);
		mapIsLoaded = true
	}

	log.Println("Save map request completed")
}

func testServer(w http.ResponseWriter, r *http.Request) {
	fmt.Printf("Recv test request\n")
	fmt.Println(w, "Server is up and running")
}

func main() {
	fmt.Printf("Running...\n") 

	// init logger
	f, err := os.OpenFile("log.txt",
		os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()
	log.SetOutput(f)

	router := mux.NewRouter().StrictSlash(true)

	router.HandleFunc("/test", testServer).Methods("GET")
	router.HandleFunc("/getMap", getMap).Methods("GET")
	router.HandleFunc("/getMapList", getMapList).Methods("GET")
	router.HandleFunc("/createMap", createMap).Methods("POST")
	router.HandleFunc("/saveMap", saveMap).Methods("PUT")

	log.Fatal(http.ListenAndServe(":"+port, router))
}

